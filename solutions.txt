"""
- create/reads a sqlite transactions table (dummy data)
- export table as CSV
- Read Local Customer CSV
- Inner joins in Acc No


"""

from pathlib import Path
import sqlite3
import pandas as pd
import logging
from logging.handlers import RotatingFileHandler
import sys
from typing import Dict,Tuple

# ------configuration-------

BASE_DIR= Path("temp")
DB_FILE= BASE_DIR / "banking.db"
DB_EXPORT_CSV= BASE_DIR / "db_export.csv"
CUSTOMER_CSV= BASE_DIR / "custome_details.csv"
FINAL_REPORT= BASE_DIR / "final_report.csv"
LOG_FILE= BASE_DIR / "banking.etl.log"

CONVERSION_RATES: Dict[str,float]= {
    "USD" : 1.0,
    "INR": 0.012,
    "EUR": 1.08
}
REQUIRED_DB_COLUMNS= {
   "Account_Number", "Customer_Name", "Branch_Code", "Transaction_Date", "Transaction_Type", "Transaction_Amount", "Balance", "Currency", "Account_Status"
}
REQUIRED_CUSTOMER_COLUMNS={"Account_Number", "Customer_Email","Customer_Phone"}

#------- Loging Setup--------

def setup_logging(log_file: Path) -> None:
    log_file.parent.mkdir(parents= True,exist_ok=True)
    logger=logging.getLogger()
    logger.setLevel(logging.DEBUG)

    fmt= logging.Formatter("%(asctime)s - %(levelname)s - %(name)s - %(message)s")

    # console handler

    ch= logging.StreamHandler(sys.stdout)
    ch.setLevel(logging.INFO)
    ch.setFormatter(fmt)
    logger.addHandler(ch)

    # Rotating File handler (DEBUG)
    fh=RotatingFileHandler(log_file,maxBytes=5 * 1024 * 1024,backupCount=3)
    fh.setLevel(logging.DEBUG)
    fh.setFormatter(fmt)
    logger.addHandler(fh)

logger= logging.getLogger(__name__)

#-------- DB Utilities-----------

def init_sqlite_with_dummy_data(db_path: Path) -> None:
    """
    Create SQLite DB and insert dummy transaction record if table is empty
    """
    logger.debug("Initializing SQLite DB at %s", db_path)
    db_path.parent.mkdir(parents=True,exist_ok=True)

    try:
        with sqlite3.connect(str(db_path)) as conn:
            cur= conn.cursor()
            cur.execute("""
                CREATE TABLE IF NOT EXISTS transactions (
                        Account_Number INTEGER,
                        Customer_Name TEXT,
                        Branch_Code TEXT, 
                        Transaction_Date TEXT,
                        Transaction_Type TEXT,
                        Transaction_Amount REAL,
                        Balance REAL,
                        Currency TEXT,
                        Account_Status TEXT
                )
            """)
            # Insert only if empty

            cur.execute("SELECT COUNT(1) FROM transactions")
            count= cur.fetchone()[0]
            if count == 0:
                logger.info("Inserting dummy data into transactions table")
                transactions_data=[
                     (1001, 'john DOE', 'B001', '2024-01-15', 'Deposit', 5000, 15000, 'usd', 'Active'),
                     (1002, 'alice SMITH', 'B002', '2024-02-10', 'Withdrawal', 2000, 8000, 'inr', 'Active'),
                     (1003, 'Bob Johnson', 'B001', '2024-02-22', 'Deposit', 3000, 12000, 'usd', 'Closed'),
                     (1004, 'Clara Oswald', 'B003', '2024-03-05', 'Deposit', 7000, 20000, 'eur', 'Active'),
                     (1005, 'Daniel White', 'B002', '2024-03-12', 'Withdrawal', 1500, 6500, 'usd', 'Active'),
                ]
                cur.executemany("""
                     INSERT INTO transactions
                     (Account_Number,Customer_Name,Branch_Code,Transaction_Date,Transaction_Type,Transaction_Amount,Balance,Currency,Account_Status)
                     VALUES(?,?,?,?,?,?,?,?,?)
                """, transactions_data)
                conn.commit()
                logger.debug("Dummy data commited")
            else:
                logger.debug("Transactions table already populated (%d rows)", count)
    except sqlite3.Error as e:
                logger.exception("Sqlite error while initializing DB: %s ",e)
                raise

def export_table_to_csv(db_path: Path, csv_path:Path,table_name:str= "transactions") -> None:
     logger.debug("exporting table %s from DB %s to CSV  %s",table_name,db_path,csv_path)
     try:
          with sqlite3.connect(str(db_path)) as conn:
               df= pd.read_sql_query(f"SELECT * FROM {table_name}" ,conn)
               if not REQUIRED_DB_COLUMNS.issubset(df.columns):
                    missing= REQUIRED_DB_COLUMNS - set(df.columns)
                    raise ValueError(f"MIssing required DB Columns: {missing}")
               csv_path.parent.mkdir(parents=True,exist_ok=True)
               df.to_csv(csv_path,index=False)
               logger.info("Exported %d rows to %s", len(df),csv_path)
     except Exception:
          logger.exception("Failed to export DB Table to CSV")
          raise


def read_csv_validate(path:Path,required_columns: set) -> pd.DataFrame:
     logger.debug('Reading csv %s',path)
     if not path.exists():
          msg= f"CSV file not found: {path}"
          logger.error(msg)
          raise FileNotFoundError(msg)
     df= pd.read_csv(path)
     logger.debug("Loaded %d rows from %s", len(df),path)
     missing= required_columns - set(df.columns)
     if missing:
          msg= f"CSV {path} is missing required columns: {missing}"
          logger.error(msg)
          raise ValueError(msg)
     return df
     

def run():
     try:
        setup_logging(LOG_FILE)
        logger.info("Starting banking ETL process")
        # step-1 init DB
        init_sqlite_with_dummy_data(DB_FILE)
        # step-2 export csv from DB
        export_table_to_csv(DB_FILE,DB_EXPORT_CSV)
        # step-3 read CSV from local system
        if not CUSTOMER_CSV.exists():
             logger.info("Customer CSV not Found",CUSTOMER_CSV)
             sample_customers=pd.DataFrame({
                  
                'Account_Number': [1001, 1002, 1003, 1004, 1005, 1006],
                'Customer_Email': ['john@example.com', 'alice@example.com', 'bob@example.com',
                                   'clara@example.com', 'daniel@example.com', 'extra@example.com'],
                'Customer_Phone': ['111-111-1111', '222-222-2222', '333-333-3333',
                                   '444-444-4444', '555-555-5555', '666-666-6666']
            
             })
             CUSTOMER_CSV.parent.mkdir(parents=True,exist_ok=True)
             sample_customers.to_csv(CUSTOMER_CSV,index=False)

     except Exception as exc:
        logger.exception("ETL Process Failed")
        return 1

if __name__ =='__main__':
     exit_code= run()
     sys.exit(exit_code)
